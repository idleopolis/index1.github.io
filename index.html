<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sylph: Autumn Equinox</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --c-text: #4a3b2a;
            --c-accent: #d4a373;
            --c-ui-bg: rgba(255, 248, 240, 0.85);
            --shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Lato', sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* Anime Filter: Vignette + Warm Overlay + Scanlines */
        #post-process {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
            background: 
                radial-gradient(circle at center, transparent 50%, rgba(60, 30, 10, 0.3) 100%),
                linear-gradient(to bottom, rgba(255, 200, 100, 0.05), rgba(100, 50, 0, 0.1));
            box-shadow: inset 0 0 150px rgba(50, 20, 0, 0.3);
            mix-blend-mode: multiply;
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            color: var(--c-text);
        }

        .hud-card {
            background: var(--c-ui-bg);
            backdrop-filter: blur(8px);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: var(--shadow);
            pointer-events: auto;
            max-width: 300px;
            transform-origin: top left;
            animation: slideIn 1s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        h1 {
            font-family: 'Cinzel', serif;
            margin: 0 0 10px 0;
            font-size: 24px;
            color: #5d4037;
            border-bottom: 2px solid var(--c-accent);
            display: inline-block;
        }

        .stat-row { display: flex; align-items: center; margin-bottom: 8px; }
        .stat-icon { width: 24px; font-size: 18px; opacity: 0.8; }
        .stat-bar-bg {
            flex-grow: 1; height: 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 4px; overflow: hidden; margin-left: 10px;
        }
        .stat-bar-fill {
            height: 100%; border-radius: 4px;
            transition: width 0.6s cubic-bezier(0.25, 1, 0.5, 1);
            box-shadow: inset 0 2px 5px rgba(255,255,255,0.3);
        }
        
        .fill-food { background: #8d6e63; }
        .fill-love { background: #e57373; }
        .fill-rest { background: #81c784; }

        .dock {
            display: flex; justify-content: center; gap: 20px;
            margin-bottom: 20px; pointer-events: auto;
        }

        .action-btn {
            width: 70px; height: 70px;
            background: var(--c-ui-bg);
            border-radius: 50%;
            border: 2px solid #fff;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            font-family: 'Cinzel', serif; font-size: 10px; font-weight: bold;
            color: var(--c-text);
        }

        .action-btn i { font-size: 24px; margin-bottom: 2px; font-style: normal; }
        .action-btn:hover { transform: translateY(-5px); background: #fff; }
        .action-btn:active { transform: scale(0.95); }

        @keyframes slideIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="world"></canvas>
    <div id="post-process"></div>

    <div id="ui-layer">
        <div class="hud-card">
            <h1>Sylph</h1>
            <div class="stat-row"><span class="stat-icon">üçÇ</span><div class="stat-bar-bg"><div id="bar-food" class="stat-bar-fill fill-food" style="width: 80%"></div></div></div>
            <div class="stat-row"><span class="stat-icon">üå∏</span><div class="stat-bar-bg"><div id="bar-love" class="stat-bar-fill fill-love" style="width: 60%"></div></div></div>
            <div class="stat-row"><span class="stat-icon">üåô</span><div class="stat-bar-bg"><div id="bar-rest" class="stat-bar-fill fill-rest" style="width: 90%"></div></div></div>
        </div>
        <div class="dock">
            <div class="action-btn" id="btn-feed"><i>üå∞</i>Offer</div>
            <div class="action-btn" id="btn-play"><i>ü¶ã</i>Play</div>
            <div class="action-btn" id="btn-rest"><i>üïØÔ∏è</i>Rest</div>
        </div>
    </div>
</div>

<script>
/**
 * ENGINE: AUTUMN UPDATE
 * Features: Procedural Trees, Wind System, Falling Leaves Physics
 */

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height;

// Palette: Autumnal
const PALETTE = {
    skyTop: '#fff8e1',
    skyBot: '#ffe0b2',
    sun: '#ffcc80',
    hills: ['#5d4037', '#795548', '#8d6e63'],
    grass: '#33691e',
    leaves: ['#d84315', '#f9a825', '#c62828', '#ef6c00', '#ff8f00'], // Red, Gold, Orange
    bark: '#3e2723'
};

// Global Wind Simulation
const wind = {
    force: 0,
    target: 0.5,
    update(t) {
        // Perlin-ish noise using sine combination
        this.target = Math.sin(t * 0.0005) + Math.sin(t * 0.002) * 0.5;
        this.force += (this.target - this.force) * 0.02;
    }
};

const game = {
    stats: { food: 80, love: 60, rest: 90 },
    state: 'idle',
    particles: [], // General particles
    leaves: [],    // Falling leaves
    trees: [],     // Tree objects
    bgElements: [] // Clouds etc
};

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    initWorld();
}

window.addEventListener('resize', resize);
const mouse = { x: 0, y: 0 };
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

// --- PROCEDURAL NATURE SYSTEMS ---

class LeafParticle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 4 + 3;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = Math.random() * 1 + 0.5;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.1;
        this.swayPhase = Math.random() * Math.PI * 2;
        this.life = 1.0;
        this.grounded = false;
    }

    update() {
        if (this.grounded) {
            this.life -= 0.005;
            return;
        }

        // Wind influence
        this.vx += (wind.force * 0.05 - this.vx) * 0.05;
        
        // Falling Physics
        this.x += this.vx + Math.sin(Date.now() * 0.005 + this.swayPhase) * 0.5;
        this.y += this.vy;
        this.rotation += this.rotSpeed + (this.vx * 0.1);

        // Ground collision
        if (this.y > height - 20) {
            this.y = height - 20 + Math.random() * 10;
            this.grounded = true;
        }
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        
        // Draw leaf shape
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
    }
}

class Tree {
    constructor(x, size) {
        this.x = x;
        this.y = height;
        this.size = size; // Scale factor
        this.foliage = []; // Clusters of leaves
        this.branches = [];
        this.generate();
    }

    generate() {
        // 1. Generate Trunk & Branches
        const trunkHeight = 150 * this.size;
        
        // Recursive branch generator
        const addBranch = (bx, by, angle, len, depth) => {
            if (depth === 0) {
                // End of branch: Add foliage cluster
                const color = PALETTE.leaves[Math.floor(Math.random() * PALETTE.leaves.length)];
                this.foliage.push({
                    x: bx, y: by, 
                    r: (30 + Math.random() * 20) * this.size,
                    color: color,
                    swayOffset: Math.random() * 10
                });
                return;
            }

            // Store branch segment
            const endX = bx + Math.cos(angle) * len;
            const endY = by + Math.sin(angle) * len;
            
            this.branches.push({ x: bx, y: by, ex: endX, ey: endY, width: depth * 4 * this.size });

            // Split
            const subLen = len * 0.7;
            const spread = 0.5; 
            addBranch(endX, endY, angle - spread, subLen, depth - 1);
            addBranch(endX, endY, angle + spread, subLen, depth - 1);
            // Occasional 3rd branch
            if(Math.random() > 0.5) addBranch(endX, endY, angle, subLen, depth - 1);
        };

        // Start tree
        addBranch(this.x, this.y, -Math.PI/2, trunkHeight, 4);
    }

    update() {
        // Chance to drop a leaf from a foliage cluster
        if (Math.random() < 0.05 + (Math.abs(wind.force) * 0.05)) {
            const source = this.foliage[Math.floor(Math.random() * this.foliage.length)];
            game.leaves.push(new LeafParticle(
                source.x + (Math.random()-0.5)*source.r, 
                source.y + (Math.random()-0.5)*source.r, 
                source.color
            ));
        }
    }

    draw(ctx, t) {
        // Sway calculation
        const sway = Math.sin(t * 0.001 + this.x) * wind.force * 10;

        ctx.save();
        // Draw Wood (Dark Silhouette style for trunk)
        ctx.strokeStyle = PALETTE.bark;
        ctx.lineCap = 'round';
        
        // Simple trunk rendering (visual only, actual data in recursion)
        ctx.beginPath();
        this.branches.forEach(b => {
            // Apply slight wind shear based on height
            const heightFactor = (height - b.y) / height;
            const shear = sway * heightFactor;
            
            ctx.lineWidth = b.width;
            ctx.moveTo(b.x + (shear*0.5), b.y);
            ctx.lineTo(b.ex + shear, b.ey);
        });
        ctx.stroke();

        // Draw Foliage (The "Anime" Look: Blobs of color)
        this.foliage.forEach(f => {
            const fSway = sway * ((height - f.y)/height);
            
            // 1. Shadow Layer (Behind)
            ctx.fillStyle = 'rgba(40, 20, 10, 0.3)';
            ctx.beginPath();
            ctx.arc(f.x + fSway + 5, f.y + 5, f.r, 0, Math.PI*2);
            ctx.fill();

            // 2. Main Color
            ctx.fillStyle = f.color;
            ctx.beginPath();
            // Draw a bubbly shape instead of perfect circle
            for(let i=0; i<5; i++) {
                let ox = Math.cos(i/5 * Math.PI*2) * (f.r * 0.5);
                let oy = Math.sin(i/5 * Math.PI*2) * (f.r * 0.5);
                ctx.arc(f.x + fSway + ox, f.y + oy, f.r * 0.7, 0, Math.PI*2);
            }
            ctx.fill();

            // 3. Highlight (Top)
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.arc(f.x + fSway - f.r*0.3, f.y - f.r*0.3, f.r * 0.4, 0, Math.PI*2);
            ctx.fill();
        });

        ctx.restore();
    }
}

function initWorld() {
    game.trees = [];
    // Background Tree (Small)
    game.trees.push(new Tree(width * 0.2, 0.6));
    // Foreground Tree (Big)
    game.trees.push(new Tree(width * 0.85, 1.1));
}

// --- RENDER HELPERS ---

function drawBackground(ctx, t) {
    // 1. Sky Gradient (Sunset/Autumn)
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, PALETTE.skyTop);
    gradient.addColorStop(1, PALETTE.skyBot);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // 2. Sun
    ctx.fillStyle = PALETTE.sun;
    ctx.shadowColor = PALETTE.sun;
    ctx.shadowBlur = 40;
    ctx.beginPath();
    ctx.arc(width * 0.7, height * 0.2, 60, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // 3. Hills
    PALETTE.hills.forEach((color, i) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        let amp = 40 - i * 10;
        let yBase = height * (0.65 + i * 0.15);
        ctx.moveTo(0, height);
        ctx.lineTo(0, yBase);
        for (let x = 0; x <= width; x += 20) {
            let y = yBase - Math.sin(x * 0.003 + i + t*0.0001) * amp;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(width, height);
        ctx.fill();
    });
}

function drawGrass(ctx, t) {
    // Only draw detailed grass near bottom
    ctx.fillStyle = PALETTE.grass;
    for(let i=0; i<width; i+=15) {
        let h = 15 + Math.sin(i * 3234) * 10;
        let sway = Math.sin(t * 0.003 + i * 0.05) * (wind.force * 10);
        
        ctx.beginPath();
        ctx.moveTo(i, height);
        ctx.quadraticCurveTo(i + sway, height - h/2, i + sway + 2, height - h);
        ctx.quadraticCurveTo(i + sway + 4, height - h/2, i + 6, height);
        ctx.fill();
    }
}

// --- PET LOGIC (SYLPH) ---

const pet = {
    x: width/2, y: height/2,
    vx: 0, vy: 0,
    radius: 50,
    squishX: 1, squishY: 1,
    blinkTimer: 0,
    
    update(dt, t) {
        let targetX = width/2, targetY = height - 100;
        if (game.state === 'playing') { targetX = mouse.x; targetY = mouse.y; }

        const ax = (targetX - this.x) * 0.05;
        const ay = (targetY - this.y) * 0.05;
        this.vx = (this.vx + ax) * 0.85;
        this.vy = (this.vy + ay) * 0.85;
        this.x += this.vx; this.y += this.vy;

        // Velocity Squish
        const speed = Math.hypot(this.vx, this.vy);
        this.squishY = 1 + Math.sin(t*0.005)*0.05 - (speed*0.005);
        this.squishX = 1 + (speed*0.005);
    },

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.squishX, this.squishY);

        // Body
        ctx.fillStyle = '#fffbf0'; 
        ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
        
        // Cel Shadow
        ctx.save();
        ctx.clip();
        ctx.fillStyle = '#ebdcc1'; // Warm shadow
        ctx.beginPath(); ctx.arc(15, 15, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Outline
        ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 3; ctx.stroke();

        // Face
        this.drawFace(ctx);
        ctx.restore();
    },

    drawFace(ctx) {
        // Eyes
        const eyeX = 18;
        if(this.blinkTimer-- <= 0) {
            if(Math.random()<0.01) this.blinkTimer = 10;
            // Open
            const drawEye = (x) => {
                ctx.fillStyle = '#5d4037';
                ctx.beginPath(); ctx.ellipse(x, -5, 6, 8, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(x-2, -8, 3, 0, Math.PI*2); ctx.fill();
            };
            drawEye(-eyeX); drawEye(eyeX);
        } else {
            // Closed
            ctx.beginPath();
            ctx.moveTo(-eyeX-8, -5); ctx.quadraticCurveTo(-eyeX, 0, -eyeX+8, -5);
            ctx.moveTo(eyeX-8, -5); ctx.quadraticCurveTo(eyeX, 0, eyeX+8, -5);
            ctx.stroke();
        }
        
        // Blush
        ctx.fillStyle = 'rgba(239, 83, 80, 0.4)';
        ctx.beginPath(); ctx.arc(-25, 10, 8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(25, 10, 8, 0, Math.PI*2); ctx.fill();

        // Mouth
        ctx.beginPath(); ctx.arc(0, 15, 5, 0, Math.PI); ctx.stroke();
    }
};

// --- GAME LOOP ---

function loop(t) {
    ctx.clearRect(0, 0, width, height);

    // 1. Logic
    wind.update(t);
    pet.update(16, t);
    
    // 2. Background
    drawBackground(ctx, t);
    
    // 3. Trees (Back)
    game.trees.forEach(tree => {
        tree.update();
        tree.draw(ctx, t);
    });

    // 4. Falling Leaves (Mid-ground)
    for (let i = game.leaves.length - 1; i >= 0; i--) {
        let l = game.leaves[i];
        l.update();
        l.draw(ctx);
        if (l.life <= 0) game.leaves.splice(i, 1);
    }
    // Limit leaf count
    if (game.leaves.length > 100) game.leaves.shift();

    // 5. Ground
    drawGrass(ctx, t);

    // 6. Character
    pet.draw(ctx);

    requestAnimationFrame(loop);
}

// --- INIT & UI ---
resize();
requestAnimationFrame(loop);

document.getElementById('btn-feed').onclick = () => {
    game.stats.food = Math.min(100, game.stats.food + 20);
    pet.squishY = 0.5; // Happy bounce
    updateUI();
};
document.getElementById('btn-play').onclick = () => {
    game.state = 'playing';
    setTimeout(() => game.state = 'idle', 3000);
};

function updateUI() {
    document.getElementById('bar-food').style.width = game.stats.food + '%';
}
setInterval(() => {
    game.stats.food = Math.max(0, game.stats.food - 1);
    updateUI();
}, 2000);

</script>
</body>
</html>
